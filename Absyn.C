//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   Program    ********************/
Program::Program(ListStm *p1)
{
  liststm_ = p1;

}

Program::Program(const Program & other)
{
  liststm_ = other.liststm_->clone();

}

Program &Program::operator=(const Program & other)
{
  Program tmp(other);
  swap(tmp);
  return *this;
}

void Program::swap(Program & other)
{
  std::swap(liststm_, other.liststm_);

}

Program::~Program()
{
  delete(liststm_);

}

void Program::accept(Visitor *v)
{
  v->visitProgram(this);
}

Program *Program::clone() const
{
  return new Program(*this);
}



/********************   StmAssignInt    ********************/
StmAssignInt::StmAssignInt(Ident p1, ExpNum *p2)
{
  ident_ = p1;
  expnum_ = p2;

}

StmAssignInt::StmAssignInt(const StmAssignInt & other)
{
  ident_ = other.ident_;
  expnum_ = other.expnum_->clone();

}

StmAssignInt &StmAssignInt::operator=(const StmAssignInt & other)
{
  StmAssignInt tmp(other);
  swap(tmp);
  return *this;
}

void StmAssignInt::swap(StmAssignInt & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expnum_, other.expnum_);

}

StmAssignInt::~StmAssignInt()
{
  delete(expnum_);

}

void StmAssignInt::accept(Visitor *v)
{
  v->visitStmAssignInt(this);
}

StmAssignInt *StmAssignInt::clone() const
{
  return new StmAssignInt(*this);
}



/********************   StmAssignStr    ********************/
StmAssignStr::StmAssignStr(Ident p1, ExpStr *p2)
{
  ident_ = p1;
  expstr_ = p2;

}

StmAssignStr::StmAssignStr(const StmAssignStr & other)
{
  ident_ = other.ident_;
  expstr_ = other.expstr_->clone();

}

StmAssignStr &StmAssignStr::operator=(const StmAssignStr & other)
{
  StmAssignStr tmp(other);
  swap(tmp);
  return *this;
}

void StmAssignStr::swap(StmAssignStr & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expstr_, other.expstr_);

}

StmAssignStr::~StmAssignStr()
{
  delete(expstr_);

}

void StmAssignStr::accept(Visitor *v)
{
  v->visitStmAssignStr(this);
}

StmAssignStr *StmAssignStr::clone() const
{
  return new StmAssignStr(*this);
}



/********************   StmIf    ********************/
StmIf::StmIf(ExpBool *p1, Stm *p2)
{
  expbool_ = p1;
  stm_ = p2;

}

StmIf::StmIf(const StmIf & other)
{
  expbool_ = other.expbool_->clone();
  stm_ = other.stm_->clone();

}

StmIf &StmIf::operator=(const StmIf & other)
{
  StmIf tmp(other);
  swap(tmp);
  return *this;
}

void StmIf::swap(StmIf & other)
{
  std::swap(expbool_, other.expbool_);
  std::swap(stm_, other.stm_);

}

StmIf::~StmIf()
{
  delete(expbool_);
  delete(stm_);

}

void StmIf::accept(Visitor *v)
{
  v->visitStmIf(this);
}

StmIf *StmIf::clone() const
{
  return new StmIf(*this);
}



/********************   StmIfElse    ********************/
StmIfElse::StmIfElse(ExpBool *p1, Stm *p2, Stm *p3)
{
  expbool_ = p1;
  stm_1 = p2;
  stm_2 = p3;

}

StmIfElse::StmIfElse(const StmIfElse & other)
{
  expbool_ = other.expbool_->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

StmIfElse &StmIfElse::operator=(const StmIfElse & other)
{
  StmIfElse tmp(other);
  swap(tmp);
  return *this;
}

void StmIfElse::swap(StmIfElse & other)
{
  std::swap(expbool_, other.expbool_);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

StmIfElse::~StmIfElse()
{
  delete(expbool_);
  delete(stm_1);
  delete(stm_2);

}

void StmIfElse::accept(Visitor *v)
{
  v->visitStmIfElse(this);
}

StmIfElse *StmIfElse::clone() const
{
  return new StmIfElse(*this);
}



/********************   StmWhileFirst    ********************/
StmWhileFirst::StmWhileFirst(ExpBool *p1, Stm *p2)
{
  expbool_ = p1;
  stm_ = p2;

}

StmWhileFirst::StmWhileFirst(const StmWhileFirst & other)
{
  expbool_ = other.expbool_->clone();
  stm_ = other.stm_->clone();

}

StmWhileFirst &StmWhileFirst::operator=(const StmWhileFirst & other)
{
  StmWhileFirst tmp(other);
  swap(tmp);
  return *this;
}

void StmWhileFirst::swap(StmWhileFirst & other)
{
  std::swap(expbool_, other.expbool_);
  std::swap(stm_, other.stm_);

}

StmWhileFirst::~StmWhileFirst()
{
  delete(expbool_);
  delete(stm_);

}

void StmWhileFirst::accept(Visitor *v)
{
  v->visitStmWhileFirst(this);
}

StmWhileFirst *StmWhileFirst::clone() const
{
  return new StmWhileFirst(*this);
}



/********************   StmWhileSecond    ********************/
StmWhileSecond::StmWhileSecond(Stm *p1, ExpBool *p2)
{
  stm_ = p1;
  expbool_ = p2;

}

StmWhileSecond::StmWhileSecond(const StmWhileSecond & other)
{
  stm_ = other.stm_->clone();
  expbool_ = other.expbool_->clone();

}

StmWhileSecond &StmWhileSecond::operator=(const StmWhileSecond & other)
{
  StmWhileSecond tmp(other);
  swap(tmp);
  return *this;
}

void StmWhileSecond::swap(StmWhileSecond & other)
{
  std::swap(stm_, other.stm_);
  std::swap(expbool_, other.expbool_);

}

StmWhileSecond::~StmWhileSecond()
{
  delete(stm_);
  delete(expbool_);

}

void StmWhileSecond::accept(Visitor *v)
{
  v->visitStmWhileSecond(this);
}

StmWhileSecond *StmWhileSecond::clone() const
{
  return new StmWhileSecond(*this);
}



/********************   StmBlock    ********************/
StmBlock::StmBlock(ListStm *p1)
{
  liststm_ = p1;

}

StmBlock::StmBlock(const StmBlock & other)
{
  liststm_ = other.liststm_->clone();

}

StmBlock &StmBlock::operator=(const StmBlock & other)
{
  StmBlock tmp(other);
  swap(tmp);
  return *this;
}

void StmBlock::swap(StmBlock & other)
{
  std::swap(liststm_, other.liststm_);

}

StmBlock::~StmBlock()
{
  delete(liststm_);

}

void StmBlock::accept(Visitor *v)
{
  v->visitStmBlock(this);
}

StmBlock *StmBlock::clone() const
{
  return new StmBlock(*this);
}



/********************   StmOutputNum    ********************/
StmOutputNum::StmOutputNum(ExpNum *p1)
{
  expnum_ = p1;

}

StmOutputNum::StmOutputNum(const StmOutputNum & other)
{
  expnum_ = other.expnum_->clone();

}

StmOutputNum &StmOutputNum::operator=(const StmOutputNum & other)
{
  StmOutputNum tmp(other);
  swap(tmp);
  return *this;
}

void StmOutputNum::swap(StmOutputNum & other)
{
  std::swap(expnum_, other.expnum_);

}

StmOutputNum::~StmOutputNum()
{
  delete(expnum_);

}

void StmOutputNum::accept(Visitor *v)
{
  v->visitStmOutputNum(this);
}

StmOutputNum *StmOutputNum::clone() const
{
  return new StmOutputNum(*this);
}



/********************   StmOutputStr    ********************/
StmOutputStr::StmOutputStr(ExpStr *p1)
{
  expstr_ = p1;

}

StmOutputStr::StmOutputStr(const StmOutputStr & other)
{
  expstr_ = other.expstr_->clone();

}

StmOutputStr &StmOutputStr::operator=(const StmOutputStr & other)
{
  StmOutputStr tmp(other);
  swap(tmp);
  return *this;
}

void StmOutputStr::swap(StmOutputStr & other)
{
  std::swap(expstr_, other.expstr_);

}

StmOutputStr::~StmOutputStr()
{
  delete(expstr_);

}

void StmOutputStr::accept(Visitor *v)
{
  v->visitStmOutputStr(this);
}

StmOutputStr *StmOutputStr::clone() const
{
  return new StmOutputStr(*this);
}



/********************   StmExit    ********************/
StmExit::StmExit()
{

}

StmExit::StmExit(const StmExit & other)
{

}

StmExit &StmExit::operator=(const StmExit & other)
{
  StmExit tmp(other);
  swap(tmp);
  return *this;
}

void StmExit::swap(StmExit & other)
{

}

StmExit::~StmExit()
{

}

void StmExit::accept(Visitor *v)
{
  v->visitStmExit(this);
}

StmExit *StmExit::clone() const
{
  return new StmExit(*this);
}



/********************   EMinus    ********************/
EMinus::EMinus(ExpNum *p1)
{
  expnum_ = p1;

}

EMinus::EMinus(const EMinus & other)
{
  expnum_ = other.expnum_->clone();

}

EMinus &EMinus::operator=(const EMinus & other)
{
  EMinus tmp(other);
  swap(tmp);
  return *this;
}

void EMinus::swap(EMinus & other)
{
  std::swap(expnum_, other.expnum_);

}

EMinus::~EMinus()
{
  delete(expnum_);

}

void EMinus::accept(Visitor *v)
{
  v->visitEMinus(this);
}

EMinus *EMinus::clone() const
{
  return new EMinus(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

EAdd::~EAdd()
{
  delete(expnum_1);
  delete(expnum_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

ESub::ESub(const ESub & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

ESub::~ESub()
{
  delete(expnum_1);
  delete(expnum_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

EMul::EMul(const EMul & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

EMul::~EMul()
{
  delete(expnum_1);
  delete(expnum_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

EDiv::~EDiv()
{
  delete(expnum_1);
  delete(expnum_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EMod    ********************/
EMod::EMod(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

EMod::EMod(const EMod & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

EMod &EMod::operator=(const EMod & other)
{
  EMod tmp(other);
  swap(tmp);
  return *this;
}

void EMod::swap(EMod & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

EMod::~EMod()
{
  delete(expnum_1);
  delete(expnum_2);

}

void EMod::accept(Visitor *v)
{
  v->visitEMod(this);
}

EMod *EMod::clone() const
{
  return new EMod(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   ENumVar    ********************/
ENumVar::ENumVar(Ident p1)
{
  ident_ = p1;

}

ENumVar::ENumVar(const ENumVar & other)
{
  ident_ = other.ident_;

}

ENumVar &ENumVar::operator=(const ENumVar & other)
{
  ENumVar tmp(other);
  swap(tmp);
  return *this;
}

void ENumVar::swap(ENumVar & other)
{
  std::swap(ident_, other.ident_);

}

ENumVar::~ENumVar()
{

}

void ENumVar::accept(Visitor *v)
{
  v->visitENumVar(this);
}

ENumVar *ENumVar::clone() const
{
  return new ENumVar(*this);
}



/********************   StmReadInt    ********************/
StmReadInt::StmReadInt()
{

}

StmReadInt::StmReadInt(const StmReadInt & other)
{

}

StmReadInt &StmReadInt::operator=(const StmReadInt & other)
{
  StmReadInt tmp(other);
  swap(tmp);
  return *this;
}

void StmReadInt::swap(StmReadInt & other)
{

}

StmReadInt::~StmReadInt()
{

}

void StmReadInt::accept(Visitor *v)
{
  v->visitStmReadInt(this);
}

StmReadInt *StmReadInt::clone() const
{
  return new StmReadInt(*this);
}



/********************   StmLength    ********************/
StmLength::StmLength(ExpStr *p1)
{
  expstr_ = p1;

}

StmLength::StmLength(const StmLength & other)
{
  expstr_ = other.expstr_->clone();

}

StmLength &StmLength::operator=(const StmLength & other)
{
  StmLength tmp(other);
  swap(tmp);
  return *this;
}

void StmLength::swap(StmLength & other)
{
  std::swap(expstr_, other.expstr_);

}

StmLength::~StmLength()
{
  delete(expstr_);

}

void StmLength::accept(Visitor *v)
{
  v->visitStmLength(this);
}

StmLength *StmLength::clone() const
{
  return new StmLength(*this);
}



/********************   StmPosition    ********************/
StmPosition::StmPosition(ExpStr *p1, ExpStr *p2)
{
  expstr_1 = p1;
  expstr_2 = p2;

}

StmPosition::StmPosition(const StmPosition & other)
{
  expstr_1 = other.expstr_1->clone();
  expstr_2 = other.expstr_2->clone();

}

StmPosition &StmPosition::operator=(const StmPosition & other)
{
  StmPosition tmp(other);
  swap(tmp);
  return *this;
}

void StmPosition::swap(StmPosition & other)
{
  std::swap(expstr_1, other.expstr_1);
  std::swap(expstr_2, other.expstr_2);

}

StmPosition::~StmPosition()
{
  delete(expstr_1);
  delete(expstr_2);

}

void StmPosition::accept(Visitor *v)
{
  v->visitStmPosition(this);
}

StmPosition *StmPosition::clone() const
{
  return new StmPosition(*this);
}



/********************   StmConcat    ********************/
StmConcat::StmConcat(ExpStr *p1, ExpStr *p2)
{
  expstr_1 = p1;
  expstr_2 = p2;

}

StmConcat::StmConcat(const StmConcat & other)
{
  expstr_1 = other.expstr_1->clone();
  expstr_2 = other.expstr_2->clone();

}

StmConcat &StmConcat::operator=(const StmConcat & other)
{
  StmConcat tmp(other);
  swap(tmp);
  return *this;
}

void StmConcat::swap(StmConcat & other)
{
  std::swap(expstr_1, other.expstr_1);
  std::swap(expstr_2, other.expstr_2);

}

StmConcat::~StmConcat()
{
  delete(expstr_1);
  delete(expstr_2);

}

void StmConcat::accept(Visitor *v)
{
  v->visitStmConcat(this);
}

StmConcat *StmConcat::clone() const
{
  return new StmConcat(*this);
}



/********************   StmSubstr    ********************/
StmSubstr::StmSubstr(ExpStr *p1, ExpNum *p2, ExpNum *p3)
{
  expstr_ = p1;
  expnum_1 = p2;
  expnum_2 = p3;

}

StmSubstr::StmSubstr(const StmSubstr & other)
{
  expstr_ = other.expstr_->clone();
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

StmSubstr &StmSubstr::operator=(const StmSubstr & other)
{
  StmSubstr tmp(other);
  swap(tmp);
  return *this;
}

void StmSubstr::swap(StmSubstr & other)
{
  std::swap(expstr_, other.expstr_);
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

StmSubstr::~StmSubstr()
{
  delete(expstr_);
  delete(expnum_1);
  delete(expnum_2);

}

void StmSubstr::accept(Visitor *v)
{
  v->visitStmSubstr(this);
}

StmSubstr *StmSubstr::clone() const
{
  return new StmSubstr(*this);
}



/********************   EStr    ********************/
EStr::EStr(String p1)
{
  string_ = p1;

}

EStr::EStr(const EStr & other)
{
  string_ = other.string_;

}

EStr &EStr::operator=(const EStr & other)
{
  EStr tmp(other);
  swap(tmp);
  return *this;
}

void EStr::swap(EStr & other)
{
  std::swap(string_, other.string_);

}

EStr::~EStr()
{

}

void EStr::accept(Visitor *v)
{
  v->visitEStr(this);
}

EStr *EStr::clone() const
{
  return new EStr(*this);
}



/********************   EStrVar    ********************/
EStrVar::EStrVar(Ident p1)
{
  ident_ = p1;

}

EStrVar::EStrVar(const EStrVar & other)
{
  ident_ = other.ident_;

}

EStrVar &EStrVar::operator=(const EStrVar & other)
{
  EStrVar tmp(other);
  swap(tmp);
  return *this;
}

void EStrVar::swap(EStrVar & other)
{
  std::swap(ident_, other.ident_);

}

EStrVar::~EStrVar()
{

}

void EStrVar::accept(Visitor *v)
{
  v->visitEStrVar(this);
}

EStrVar *EStrVar::clone() const
{
  return new EStrVar(*this);
}



/********************   StmReadStr    ********************/
StmReadStr::StmReadStr()
{

}

StmReadStr::StmReadStr(const StmReadStr & other)
{

}

StmReadStr &StmReadStr::operator=(const StmReadStr & other)
{
  StmReadStr tmp(other);
  swap(tmp);
  return *this;
}

void StmReadStr::swap(StmReadStr & other)
{

}

StmReadStr::~StmReadStr()
{

}

void StmReadStr::accept(Visitor *v)
{
  v->visitStmReadStr(this);
}

StmReadStr *StmReadStr::clone() const
{
  return new StmReadStr(*this);
}



/********************   Eeq    ********************/
Eeq::Eeq(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

Eeq::Eeq(const Eeq & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

Eeq &Eeq::operator=(const Eeq & other)
{
  Eeq tmp(other);
  swap(tmp);
  return *this;
}

void Eeq::swap(Eeq & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

Eeq::~Eeq()
{
  delete(expnum_1);
  delete(expnum_2);

}

void Eeq::accept(Visitor *v)
{
  v->visitEeq(this);
}

Eeq *Eeq::clone() const
{
  return new Eeq(*this);
}



/********************   Eneq    ********************/
Eneq::Eneq(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

Eneq::Eneq(const Eneq & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

Eneq &Eneq::operator=(const Eneq & other)
{
  Eneq tmp(other);
  swap(tmp);
  return *this;
}

void Eneq::swap(Eneq & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

Eneq::~Eneq()
{
  delete(expnum_1);
  delete(expnum_2);

}

void Eneq::accept(Visitor *v)
{
  v->visitEneq(this);
}

Eneq *Eneq::clone() const
{
  return new Eneq(*this);
}



/********************   Elt    ********************/
Elt::Elt(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

Elt::Elt(const Elt & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

Elt &Elt::operator=(const Elt & other)
{
  Elt tmp(other);
  swap(tmp);
  return *this;
}

void Elt::swap(Elt & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

Elt::~Elt()
{
  delete(expnum_1);
  delete(expnum_2);

}

void Elt::accept(Visitor *v)
{
  v->visitElt(this);
}

Elt *Elt::clone() const
{
  return new Elt(*this);
}



/********************   Egt    ********************/
Egt::Egt(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

Egt::Egt(const Egt & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

Egt &Egt::operator=(const Egt & other)
{
  Egt tmp(other);
  swap(tmp);
  return *this;
}

void Egt::swap(Egt & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

Egt::~Egt()
{
  delete(expnum_1);
  delete(expnum_2);

}

void Egt::accept(Visitor *v)
{
  v->visitEgt(this);
}

Egt *Egt::clone() const
{
  return new Egt(*this);
}



/********************   Ele    ********************/
Ele::Ele(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

Ele::Ele(const Ele & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

Ele &Ele::operator=(const Ele & other)
{
  Ele tmp(other);
  swap(tmp);
  return *this;
}

void Ele::swap(Ele & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

Ele::~Ele()
{
  delete(expnum_1);
  delete(expnum_2);

}

void Ele::accept(Visitor *v)
{
  v->visitEle(this);
}

Ele *Ele::clone() const
{
  return new Ele(*this);
}



/********************   Ege    ********************/
Ege::Ege(ExpNum *p1, ExpNum *p2)
{
  expnum_1 = p1;
  expnum_2 = p2;

}

Ege::Ege(const Ege & other)
{
  expnum_1 = other.expnum_1->clone();
  expnum_2 = other.expnum_2->clone();

}

Ege &Ege::operator=(const Ege & other)
{
  Ege tmp(other);
  swap(tmp);
  return *this;
}

void Ege::swap(Ege & other)
{
  std::swap(expnum_1, other.expnum_1);
  std::swap(expnum_2, other.expnum_2);

}

Ege::~Ege()
{
  delete(expnum_1);
  delete(expnum_2);

}

void Ege::accept(Visitor *v)
{
  v->visitEge(this);
}

Ege *Ege::clone() const
{
  return new Ege(*this);
}



/********************   OrExp    ********************/
OrExp::OrExp(ExpBool *p1, ExpBool *p2)
{
  expbool_1 = p1;
  expbool_2 = p2;

}

OrExp::OrExp(const OrExp & other)
{
  expbool_1 = other.expbool_1->clone();
  expbool_2 = other.expbool_2->clone();

}

OrExp &OrExp::operator=(const OrExp & other)
{
  OrExp tmp(other);
  swap(tmp);
  return *this;
}

void OrExp::swap(OrExp & other)
{
  std::swap(expbool_1, other.expbool_1);
  std::swap(expbool_2, other.expbool_2);

}

OrExp::~OrExp()
{
  delete(expbool_1);
  delete(expbool_2);

}

void OrExp::accept(Visitor *v)
{
  v->visitOrExp(this);
}

OrExp *OrExp::clone() const
{
  return new OrExp(*this);
}



/********************   AndExp    ********************/
AndExp::AndExp(ExpBool *p1, ExpBool *p2)
{
  expbool_1 = p1;
  expbool_2 = p2;

}

AndExp::AndExp(const AndExp & other)
{
  expbool_1 = other.expbool_1->clone();
  expbool_2 = other.expbool_2->clone();

}

AndExp &AndExp::operator=(const AndExp & other)
{
  AndExp tmp(other);
  swap(tmp);
  return *this;
}

void AndExp::swap(AndExp & other)
{
  std::swap(expbool_1, other.expbool_1);
  std::swap(expbool_2, other.expbool_2);

}

AndExp::~AndExp()
{
  delete(expbool_1);
  delete(expbool_2);

}

void AndExp::accept(Visitor *v)
{
  v->visitAndExp(this);
}

AndExp *AndExp::clone() const
{
  return new AndExp(*this);
}



/********************   EStrEq    ********************/
EStrEq::EStrEq(ExpStr *p1, ExpStr *p2)
{
  expstr_1 = p1;
  expstr_2 = p2;

}

EStrEq::EStrEq(const EStrEq & other)
{
  expstr_1 = other.expstr_1->clone();
  expstr_2 = other.expstr_2->clone();

}

EStrEq &EStrEq::operator=(const EStrEq & other)
{
  EStrEq tmp(other);
  swap(tmp);
  return *this;
}

void EStrEq::swap(EStrEq & other)
{
  std::swap(expstr_1, other.expstr_1);
  std::swap(expstr_2, other.expstr_2);

}

EStrEq::~EStrEq()
{
  delete(expstr_1);
  delete(expstr_2);

}

void EStrEq::accept(Visitor *v)
{
  v->visitEStrEq(this);
}

EStrEq *EStrEq::clone() const
{
  return new EStrEq(*this);
}



/********************   EStrNeq    ********************/
EStrNeq::EStrNeq(ExpStr *p1, ExpStr *p2)
{
  expstr_1 = p1;
  expstr_2 = p2;

}

EStrNeq::EStrNeq(const EStrNeq & other)
{
  expstr_1 = other.expstr_1->clone();
  expstr_2 = other.expstr_2->clone();

}

EStrNeq &EStrNeq::operator=(const EStrNeq & other)
{
  EStrNeq tmp(other);
  swap(tmp);
  return *this;
}

void EStrNeq::swap(EStrNeq & other)
{
  std::swap(expstr_1, other.expstr_1);
  std::swap(expstr_2, other.expstr_2);

}

EStrNeq::~EStrNeq()
{
  delete(expstr_1);
  delete(expstr_2);

}

void EStrNeq::accept(Visitor *v)
{
  v->visitEStrNeq(this);
}

EStrNeq *EStrNeq::clone() const
{
  return new EStrNeq(*this);
}



/********************   NotExp    ********************/
NotExp::NotExp(ExpBool *p1)
{
  expbool_ = p1;

}

NotExp::NotExp(const NotExp & other)
{
  expbool_ = other.expbool_->clone();

}

NotExp &NotExp::operator=(const NotExp & other)
{
  NotExp tmp(other);
  swap(tmp);
  return *this;
}

void NotExp::swap(NotExp & other)
{
  std::swap(expbool_, other.expbool_);

}

NotExp::~NotExp()
{
  delete(expbool_);

}

void NotExp::accept(Visitor *v)
{
  v->visitNotExp(this);
}

NotExp *NotExp::clone() const
{
  return new NotExp(*this);
}



/********************   TrueVal    ********************/
TrueVal::TrueVal()
{

}

TrueVal::TrueVal(const TrueVal & other)
{

}

TrueVal &TrueVal::operator=(const TrueVal & other)
{
  TrueVal tmp(other);
  swap(tmp);
  return *this;
}

void TrueVal::swap(TrueVal & other)
{

}

TrueVal::~TrueVal()
{

}

void TrueVal::accept(Visitor *v)
{
  v->visitTrueVal(this);
}

TrueVal *TrueVal::clone() const
{
  return new TrueVal(*this);
}



/********************   FalseVal    ********************/
FalseVal::FalseVal()
{

}

FalseVal::FalseVal(const FalseVal & other)
{

}

FalseVal &FalseVal::operator=(const FalseVal & other)
{
  FalseVal tmp(other);
  swap(tmp);
  return *this;
}

void FalseVal::swap(FalseVal & other)
{

}

FalseVal::~FalseVal()
{

}

void FalseVal::accept(Visitor *v)
{
  v->visitFalseVal(this);
}

FalseVal *FalseVal::clone() const
{
  return new FalseVal(*this);
}




/********************   ListStm    ********************/

void ListStm::accept(Visitor *v)
{
  v->visitListStm(this);
}


ListStm *ListStm::clone() const
{
  return new ListStm(*this);
}




